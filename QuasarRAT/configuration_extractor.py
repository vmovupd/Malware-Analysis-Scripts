"""
Configuration extractor for QuasarRAT. Configuration structure is hardcoded in main()

The script has been tested on the following samples:
2259304db67dd25fa5ce47bde5b1c8cffab23292c2cec7d3bc2a0c303aace85b
17473731182bcea4cee088d78f802ea947926a5cbc8708b4ba31d7585ee8b19f
a7e7d00dbcfded8345042410b362d04338fa33dea700a9cdf18679578f6d51af
716153d5958b307c96be985da422552195800586967911ec5a69d4aa3e7236e7
"""

import argparse, clr, base64, sys
from Crypto.Cipher import AES
from Crypto.Protocol.KDF import PBKDF2
from System import BitConverter

def ExtDeriveKeyArgs(method, opcodes, operand_value, derive_key_args):
    """Locates arguments for key derivation function leveraging configuration method and one of the encrypted strings."""
    quasar_crypto_class = None
    for m in method.DeclaringType.Methods:
        if m == method:
            continue

        instr_list = [instr for instr in m.Body.Instructions]
        for i in range(len(instr_list)):
            if instr_list[i].OpCode == opcodes.Ldsfld and instr_list[i].Operand == operand_value and instr_list[i + 1].OpCode == opcodes.Callvirt:
                quasar_crypto_class = instr_list[i + 1].Operand.DeclaringType
                break
    
    if quasar_crypto_class == None:
        print("[*] Class responsible for QuasarRAT's cryptography was not found. Exiting")
        sys.exit(1)
    
    for constr in quasar_crypto_class.FindConstructors():
        if (constr.Name == ".ctor"):
            for instr in constr.Body.Instructions:
                if (instr.OpCode == opcodes.Ldc_I4):
                    derive_key_args["iterations"] = instr.Operand
        if (constr.Name == ".cctor"):
            for instr in constr.Body.Instructions:
                if (instr.OpCode == opcodes.Ldtoken):
                    derive_key_args["salt"] = bytes.fromhex(BitConverter.ToString(instr.Operand.InitialValue).replace("-", ''))
    
    print("[+] Arguments for key derivation function is located and extracted from class with token: {}".format(quasar_crypto_class.MDToken.ToString()))

def IsConfigMethod(method, opcodes, config, derive_key_args):
    """Checks whether a given method contains a pattern with configuration initialization. 
    If so, it writes configuration to the passed list of tuples (config); arguments for key derivation function to the passed dictionary (derive_key_args) through ExtDeriveKeyArgs."""
    init_config = [opcodes.Ldstr, opcodes.Stsfld, opcodes.Ldstr, opcodes.Stsfld, opcodes.Ldc_I4]
    
    opcodes_list = [instr.OpCode for instr in method.Body.Instructions]
    operand_list = [instr.Operand for instr in method.Body.Instructions]
    
    if (len(opcodes_list) < len(init_config)):
        return False
    
    if opcodes_list[0:len(init_config)] == init_config:
        j = 0
        ExtDeriveKeyArgs(method, opcodes, operand_list[1], derive_key_args)
        for i in range(len(opcodes_list)):
            if ((opcodes_list[i] == opcodes.Ldstr and operand_list[i] != '') or opcodes_list[i] == opcodes.Ldc_I4):
                config[j][1] = operand_list[i]
                j += 1
        print("[+] Configuration is located and extracted from method with token: {}".format(method.MDToken.ToString()))
        return True
    else:
        return False

def DecryptConfig(config, derive_key_args):
    """Decrypts the QuasarRAT configuration passed. It does not print empty strings from the config."""
    
    # same can be done without pycryptodome, using C# methods from System.Security.Cryptography
    derived_key = PBKDF2(config[7][1], derive_key_args["salt"], 32, derive_key_args["iterations"])
    for i in range(len(config)):
        if i == 7:
            print("[+] {} is {}".format(config[i][0], config[i][1]))
            continue
        
        if config[i][1] == '':
            continue
        
        try:
            config[i][1] = bytearray(base64.b64decode(config[i][1]))
            iv = (config[i][1])[32:48]
            cipher = (config[i][1])[48:]
            aes = AES.new(bytes(derived_key), AES.MODE_CBC, iv)
            config[i][1] = aes.decrypt(cipher).decode("utf-8").strip()
            print("[+] {} is {}".format(config[i][0], config[i][1]))
        except Exception:
            print("[+] {} is {}".format(config[i][0], config[i][1]))
            continue
    
    # config list can be also converted into dictionary for better parsing
    #config = dict(config)

def main(args, opcodes):
    pe = dnlib.DotNet.ModuleDefMD.Load(args.file)
    
    config = [
        ["version", ''],
        ["hosts", ''],
        ["reconnect_delay", 0],
        ["directory", ''],
        ["subdirectory", ''],
        ["install_name", ''],
        ["mutex", ''],
        ["encryption_key", ''],
        ["tag", ''],
        ["log_directory_name", ''],
        ["server_signature", ''],
        ["server_certificate", ''],
        ["install_path", ''],
        ["logs_path", '']
        ]
    
    derive_key_args = { "salt": b'', "iterations": 0 }
    
    for Type in pe.GetTypes():
        for method in Type.Methods:
            if method.HasBody and IsConfigMethod(method, opcodes, config, derive_key_args):
                DecryptConfig(config, derive_key_args)
                return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Configuration extractor for QuasarRAT", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('-f', '--file', required=True, help='Full path to the sample', default=argparse.SUPPRESS)
    parser.add_argument('--dnlib', required=True, help='Full path to dnlib.dll', default=argparse.SUPPRESS)
    
    clr.AddReference(parser.parse_args().dnlib)
    
    import dnlib
    from dnlib.DotNet.Emit import OpCodes
    main(parser.parse_args(), OpCodes)