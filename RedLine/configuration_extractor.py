"""
Configuration extractor for RedLine infostealer which is also capable of retrieving configuration from Confuser obfuscated binaries by emulating methods responsible for configuration's string initialization. In order to emulate methods, python with the appropriate architecture must be used.

Configuration structure: [IP, ID, Message, Key]

The script has been tested on the following samples:
45cc187817706afe6935abbbdc7c385df42f6aa8974976c1d38962ab00365737
2b568c0cf29aad37241a01e5dd8f60343466d6380caff108c4f4efd4949837a7
dd5a3d0e88f9e4bfda77946815afb47b3929e06600d70554afc6816b2f5dde77
86e914fbde6a462030cf55bb9149cbf9ae8dabe7c2f8add66b9d5824dacc6155
"""

import argparse, clr, base64, os, re, hashlib
from tempfile import gettempdir
from System import Int32
from System.Reflection import Assembly
from System.IO import File

def IsConfigMethod(method, opcodes, config):
    """Checks whether a given method contains a pattern with configuration initialization. 
    If so, it writes configuration to the passed list."""
    init_config = [opcodes.Ldstr, opcodes.Stsfld]*4
    
    opcodes_list = [instr.OpCode for instr in method.Body.Instructions]
    operand_list = [instr.Operand for instr in method.Body.Instructions]

    try:
        for i in range(len(opcodes_list)):    
            if opcodes_list[i:(i + len(init_config))] == init_config:
                for j in range(i, i + len(init_config), 2):
                    config.append(operand_list[j])
                return True
    except IndexError:
        return False
    
    return False

def IsConfigMethodObfuscated(method, opcodes, config):
    """Checks whether a given method contains a pattern with configuration initialization that is obfuscated by Confuser. 
    If so, for each obfuscated string, it writes tuple with an argument and MethodSpec to the passed list.
    If there are plaintext strings, they will be written to the list as well."""
    init_config = [opcodes.Ldc_I4, opcodes.Br_S, opcodes.Call, opcodes.Stsfld]
    
    opcodes_list = [instr.OpCode for instr in method.Body.Instructions]
    operand_list = [instr.Operand for instr in method.Body.Instructions]
        
    if opcodes_list[0:len(init_config)] == init_config:
        for j in range(0, len(opcodes_list)):
            if opcodes_list[j] == opcodes.Ret:
                return True
                    
            if opcodes_list[j] == opcodes.Ldc_I4:
                config.append((operand_list[j], operand_list[j + 2]))
                    
            if opcodes_list[j] == opcodes.Ldstr:
                config.append(operand_list[j])
                if opcodes_list[j + 2] == opcodes.Ldstr:
                     config.append(operand_list[j + 2])
    else:
        return False

def RemoveAntiInvoke(method, opcodes):
    """Checks whether a given method contains a pattern with anti Invoke instructions. 
    If so, it removes them using NOPs."""
    anti_invoke = [opcodes.Call, opcodes.Call, opcodes.Callvirt, opcodes.Brfalse]
    
    opcodes_list = [instr.OpCode for instr in method.Body.Instructions]
    
    if opcodes_list[0:len(anti_invoke)] == anti_invoke:
        j = 0
        for instr in method.Body.Instructions:
            instr.OpCode = opcodes.Nop
            j += 1
            if (j == len(anti_invoke)):
                break
        return True
    else:
        return False

def xor(data, key):
    for i in range(len(data)):
        keybyte = key[i % len(key)]
        data[i] = data[i] ^ keybyte
    return data

def DecryptConfig(config):
    """Decrypts the RedLine configuration passed and prints the result. 
    It doesn't print Message string if it is empty."""
    print("[+] XOR key extracted: {}".format(config[3]))
    
    for i in range(0, 2):
        try:
            config[i] = base64.b64decode(xor(bytearray(base64.b64decode(config[i].encode('utf-8'))), bytearray(config[3].encode('utf-8')))).decode("utf-8")
        except Exception:
            continue
    print("[+] C2 extracted: {}".format(config[0]))
    print("[+] ID extracted: {}".format(config[1]))
    if config[2] != '':
        print("[+] Message extracted: {}".format(config[2]))

def main(args, opcodes):
    pe = dnlib.DotNet.ModuleDefMD.Load(args.file)
    config = []
    
    # Extract authentication value using regex
    for pos in range(pe.USStream.get_StreamLength()):
        if pe.USStream.Read(pos) == None:
            continue
        if re.search("[0-9a-f]{32}", pe.USStream.Read(pos)):
            print("[+] Authentication value extracted: {}".format(pe.USStream.Read(pos)))
            break
    
    # Extract the configuration
    for Type in pe.GetTypes():
        for method in Type.Methods:
            if method.HasBody and IsConfigMethod(method, opcodes, config):
                DecryptConfig(config)
                return
               
            if method.HasBody and IsConfigMethodObfuscated(method, opcodes, config):
                for i in range(len(config)):
                    try:
                        if RemoveAntiInvoke(pe.ResolveMethod(config[i][1].Method.Rid), opcodes):
                            print("[+] Removed anti Invoke instructions from method with token: {}".format(config[i][1].Method.MDToken.ToString()))
                    except AttributeError:
                        continue
                    except IndexError:
                        continue

                with open(args.file, 'rb') as f:
                    hash_value = hashlib.md5(f.read()).hexdigest();
                outpath = gettempdir() + "\\nopped_" + hash_value + ".bin" # MD5 value of the passed sample is used for the filename
                pe.Write(outpath)   # save redline with nopped anti Invoke instructions
                print("[+] Created file with nopped instructions in %TEMP% directory")
                
                sample = Assembly.Load(File.ReadAllBytes(outpath)).GetModules()[0]
                for i in range(len(config)):
                    try:
                        print("[+] Invoking method with token: {}".format(config[i][1].Method.MDToken.ToString()))
                        config[i] = (sample.ResolveMethod(config[i][1].MDToken.ToInt32())).Invoke(None, [Int32(config[i][0])])
                    except (IndexError, AttributeError):
                        continue
                
                # Deleting the created sample
                sample = None
                try:
                    os.remove(outpath)
                    print("[+] Deleted file with nopped instructions in %TEMP% directory")
                except FileNotFoundError:
                    print("[*] File with nopped instructions was not found")
                
                DecryptConfig(config)
                return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Configuration extractor for RedLine infostealer", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('-f', '--file', required=True, help='Full path to the sample', default=argparse.SUPPRESS)
    parser.add_argument('--dnlib', required=True, help='Full path to the dnlib.dll', default=argparse.SUPPRESS)
    
    clr.AddReference(parser.parse_args().dnlib)
    
    import dnlib
    from dnlib.DotNet.Emit import OpCodes
    main(parser.parse_args(), OpCodes)