"""
Payload extractor for the first stage loader which uses Process Hollowing technique to inject the embedded executable into InstallUtil.exe (probably other legitimate executables as well). The payload is encrypted using RC4.

The script has been tested on the following samples:
a5ff470309ffbf1a057b60eaf91883b56f0b11a4e76249d71ce2ab41896fb55a
d554c3844613b585d9b9399ec67bc75ad368a45cf0a06a8bdd4c06a29232e10b
d3e3f4a6d888316cf8bc1bf4a57f0d9359465a79a4479a76f80d117151f40057
"""

import rzpipe, argparse, sys
from arc4 import ARC4

RC4_MAX_KEY_SIZE = 256

def LocateExtractPayload(pipe):
    """Locates the decryption routine in the binary. Extracts an encrypted payload and an RC4 key."""
    xor_address = pipe.cmdj("/xj 30........004.81..........") # xor payload[reg], reg + inc reg + cmp reg, val
    
    if (len(xor_address) == 0):
        print("[*] There is no instance matching the pattern. Exiting")
        sys.exit(1)
    
    if (len(xor_address) > 1):
        print("[*] There are more than one XOR instruction matching the pattern. The output may be wrong")
    
    xor_address = xor_address[0]["offset"]
    print("[+] Determined XOR instruction virtual addres: " + hex(xor_address))
    instr = pipe.cmdj("pdj 1 @ " + hex(xor_address))
    func_start = instr[0]["fcn_addr"]
    func_end = instr[0]["fcn_last"]
    payload_address = instr[0]["xrefs_from"][0]["addr"]
    
    # Determine the size of an encrypted payload and extract the payload
    payload_size = pipe.cmdj("pdj 1 @ " + hex(xor_address + instr[0]["size"] + 1))[0]["val"]
    pipe.cmd("s " + hex(payload_address))
    payload = pipe.cmdj("pxj @!" + str(payload_size)) # fixing 256 bytes limit for pxj by changing the block size and grabbing the payload
    
    print("[+] Determined encrypted payload virtual addres: " + hex(payload_address))
    print("[+] Determined encrypted payload size (bytes): " + str(payload_size))
    
    # Locate RC4 key, its size and extract it
    sub_address = pipe.cmdj("/xj 2B..8A........00 @(" + hex(func_start) + " " + hex(xor_address) + ")")[0]["offset"] # sub reg, reg + mov, reg, key[reg]
    instr = pipe.cmdj("pdj 1 @ " + hex(sub_address))
    key_address = pipe.cmdj("pdj 1 @ " + hex(sub_address + instr[0]["size"]))[0]["xrefs_from"][0]["addr"]
    
    key = pipe.cmdj("pxj " + hex(RC4_MAX_KEY_SIZE + 3) + " @ " + hex(key_address))
    key_size = 0
    for i in range(RC4_MAX_KEY_SIZE):
        if (key[(i + 1):(i + 4)] == [0, 0, 0]):
            key_size = i
            break
    
    for i in range(1, len(key) - key_size):
        key.pop()
    
    print("[+] Determined RC4 key virtual addres: " + hex(key_address))
    print("[+] Determined RC4 key size (bytes): " + str(key_size + 1))
    
    return bytes(key), bytes(payload)

def main(args):
    with rzpipe.open(args.file) as rz:
        rz.cmd("aaa")
        key, encrypted_payload = LocateExtractPayload(rz)
        rc4 = ARC4(key)
        payload = rc4.decrypt(encrypted_payload)
    
        with open(args.output, "wb") as f:
            f.write(payload)
        print("[+] Payload has been decrypted and written to " + args.output)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Payload extractor for RedLine infostealer's 1st stage loader", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('-f', '--file', required=True, help='Full path to 1st stage loader', default=argparse.SUPPRESS)
    parser.add_argument('-o', '--output', help='Output filename', default='payload.bin')
    
    main(parser.parse_args())
