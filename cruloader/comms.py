import rzpipe, sys, requests, argparse, re

CRULOADER_STRING = "cruloader"  # meaningful string used in LocateConfig() and as a default user agent in GetImg()

REGEX = "^[a-z]{9}$"    # used in LocateConfigRegEx(), instead of CRULOADER_STRING with the same purpose

PAYLOAD_EXE_FLAG_SIZE = 9   # size of the string which identifies the start of the encrypted payload in the image
PAYLOAD_XOR_KEY_SIZE = 16   # size of xor key to decrypt the payload

def rtl(b, n):
    return ((b << n) | (b >> (8 - n))) & 0xff

def DecryptStr(enc_str, rol_num, xor_key):
    decrypted_str = ""
    for i in range(len(enc_str)):
        decrypted_str += chr(rtl(enc_str[i], rol_num) ^ xor_key)
    return decrypted_str

def GetStringInfo(pipe, address):
    strinf = pipe.cmdj("pszj @ " + hex(address))
    return strinf if strinf else ''

def GetXrefFuncAddress(pipe, address):
    xref = pipe.cmdj("axtj @ " + hex(address))
    return '' if not xref else pipe.cmdj("pdj 1 @ " + hex(xref[0]["from"]))[0]["fcn_addr"]

def LocateConfig(pipe):
    """"Locates the configuration range, based on meaningful string CRULOADER_STRING."""
    config_range = []
    for string in pipe.cmdj("izj"):
        if(string["string"] == CRULOADER_STRING):
            config_range.append(string['vaddr'])
        if len(config_range) == 2:
            break
    if len(config_range) == 0:
        print("[*] Error locating the config. Exiting")
        pipe.quit()
        sys.exit(1)
    config_range[0] += GetStringInfo(pipe, config_range[0])["length"]
    return config_range

def LocateConfigRegEx(pipe):
    """"Locates the configuration range, based on regular expression pattern REGEX."""
    config_range = []
    pattern = re.compile(REGEX)
    for string in pipe.cmdj("izj"):
        if(re.fullmatch(pattern, str(string["string"])) != None):
            config_range.append(string['vaddr'])
        if len(config_range) == 2:
            break
    if len(config_range) == 0:
        print("[*] Error locating the config. Exiting")
        pipe.quit()
        sys.exit(1)
    user_agent = pipe.cmdj("pszj @ " + hex(config_range[0]))["string"]
    config_range[0] += GetStringInfo(pipe, config_range[0])["length"]
    return config_range, user_agent

def DecryptConfig(pipe, config_range):
    """"Automatically locates encrypted strings within the given config range and decrypts them, returning a list of decrypted strings."""
    dec_pair = []
    config = []
    cur_enc_str_addr = config_range[0]
    while (cur_enc_str_addr < config_range[1]):
        while not GetStringInfo(pipe, cur_enc_str_addr) and cur_enc_str_addr < config_range[1]:
            cur_enc_str_addr += 1
        
        cur_xref = GetXrefFuncAddress(pipe, cur_enc_str_addr)
        next_enc_str_addr = cur_enc_str_addr + GetStringInfo(pipe, cur_enc_str_addr)["length"] + 1
        while (((not GetStringInfo(pipe, next_enc_str_addr) or (not GetXrefFuncAddress(pipe, next_enc_str_addr))) or GetXrefFuncAddress(pipe, next_enc_str_addr) == cur_xref) and next_enc_str_addr < config_range[1]):
            next_enc_str_addr += 1

        func_end = pipe.cmdj("pdj 1 @ " + hex(cur_xref))[0]["fcn_last"]
        rol_instr = pipe.cmdj("pdj 1 @ " + hex(cur_xref + pipe.cmdj("pdj 1 @ " + hex(cur_xref))[0]["size"]))
        while (rol_instr[0]["type"] != "rol" and rol_instr[0]["offset"] != func_end):
            rol_instr = pipe.cmdj("pdj 1 @ " + hex(rol_instr[0]["offset"] + rol_instr[0]["size"]))

        xor_instr = pipe.cmdj("pdj 1 @ " + hex(rol_instr[0]["offset"] + rol_instr[0]["size"]))
        if xor_instr[0]["type"] != "xor":
            cur_enc_str_addr += GetStringInfo(pipe, cur_enc_str_addr)["length"] + 1
            continue
            
        enc_str = pipe.cmdj("pxj " + str(next_enc_str_addr - cur_enc_str_addr) + " @ " + hex(cur_enc_str_addr))
        dec_pair.append((int(rol_instr[0]["opcode"].split(',')[1].strip()), xor_instr[0]["val"]))
        
        while enc_str[-1] == 0:
            enc_str.pop()
        
        decrypted_str = DecryptStr(enc_str, dec_pair[-1][0], dec_pair[-1][1])
        print("[+] Decrypted string at {}: {}".format(hex(cur_enc_str_addr), decrypted_str))
        config.append(decrypted_str)
        
        cur_enc_str_addr = next_enc_str_addr
    if len(config) == 0:
        print("[*] No strings located in config range {}. Exiting".format(config_range))
        pipe.quit()
        sys.exit(1)
    return config

def GetImg(url, useragent=CRULOADER_STRING):
    """"Retrieves an image with a payload from a specified URL and returns it as bytes."""
    headers = {'User-Agent': useragent}
    print("[+] Retrieving URL to the image from {}".format(url))
    response = requests.get(url, headers=headers)
    if response.status_code == 200:
        print("[+] Retrieved URL with an image: {}".format(response.text))
        image_response = requests.get(response.text, headers=headers)
        if image_response.status_code == 200:
            return image_response.content
        else:
            print("[*] Unable to connect to {}. HTTP status code: {}".format(response.text, image_response.status_code))
            return None
    else:
        print("[*] Unable to connect to {}. HTTP status code: {}".format(url, response.status_code))
        return None

def DecryptPayload(filedata, exe_flag, key, outputfilename):
   """"Locates and decrypts the payload from the given file using the specified exe flag and key; writes the decrypted payload to the specified output file."""
   try:
        filedata = bytearray(filedata[filedata.find(exe_flag) + len(exe_flag):])
        for i in range(len(filedata)):
            keybyte = key[i % len(key)]
            filedata[i] = filedata[i] ^ keybyte

        with open(outputfilename, 'wb') as payload:
            payload.write(filedata)
            print("[+] Payload has been decrypted and written to {}".format(outputfilename))
   except ValueError:
        print("[*] Couldn't locate the executable flag in the image.")

def LocateDecryptPayloadCfg(pipe, config_range):
    """Locates and decrypts the payload configuration data within the given range."""
    payload_cfg_addr = 0
    for string in pipe.cmdj("izj"): # limitations of rizin; psj doesn't recognize unicode string
        if string["vaddr"] == config_range[1]:
            payload_cfg_addr = string["size"] + string["vaddr"]
            break

    xref_exe_flag = pipe.cmdj("axtj @ " + hex(payload_cfg_addr + PAYLOAD_EXE_FLAG_SIZE - 1))[0]["from"]
    func_end = pipe.cmdj("pdj 1 @ " + hex(xref_exe_flag))[0]["fcn_last"]
    
    rol_instr = pipe.cmdj("pdj 1 @ " + hex(xref_exe_flag + pipe.cmdj("pdj 1 @ " + hex(xref_exe_flag))[0]["size"]))
    while (rol_instr[0]["type"] != "rol" and rol_instr[0]["offset"] != func_end):
        rol_instr = pipe.cmdj("pdj 1 @ " + hex(rol_instr[0]["offset"] + rol_instr[0]["size"]))

    rol_num = int(rol_instr[0]["opcode"].split(',')[1].strip())
    xor_key = pipe.cmdj("pdj 1 @ " + hex(rol_instr[0]["offset"] + rol_instr[0]["size"]))[0]["val"]
    
    exe_flag = DecryptStr(pipe.cmdj("pxj " + str(PAYLOAD_EXE_FLAG_SIZE) + " @ " + hex(payload_cfg_addr)), rol_num, xor_key)
    payload_xor_key = pipe.cmdj("pxj " + str(PAYLOAD_XOR_KEY_SIZE) + " @ " + hex(payload_cfg_addr + PAYLOAD_EXE_FLAG_SIZE + 3)) # 3 null-bytes between exe flag and payload key
    return exe_flag, payload_xor_key

def main(args):
    with rzpipe.open(args.file) as rz:
        rz.cmd("aaa")
        config_range = LocateConfig(rz)
        # For regex search:
        # config_range, user_agent = LocateConfigRegEx(rz)
        config = DecryptConfig(rz, config_range)
        exe_flag, payload_key = LocateDecryptPayloadCfg(rz, config_range)
    for string in config:
        if "http" in string:
           image = GetImg(string)
           if (image == None):
                sys.exit(1)
           DecryptPayload(image, bytes(exe_flag, "ascii"), payload_key, args.output)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Communication emulator and payload extractor for cruloader second stage", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('-f', '--file', required=True, help='Full path to the second stage', default=argparse.SUPPRESS)
    parser.add_argument('-o', '--output', help='Output filename', default='payload.bin')
    
    main(parser.parse_args())