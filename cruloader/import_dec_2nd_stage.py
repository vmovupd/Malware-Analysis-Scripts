import zlib, rzpipe, os, pefile, argparse

LIBRARY_ARRAY_SIZE = 50 # size of an array with library names is unknown

def DetermineAPI(libpath, hashed_api):
    """Determines an API name from the specified Windows library."""
    pe = pefile.PE(libpath)
    pe.parse_data_directories(directories = [pefile.DIRECTORY_ENTRY["IMAGE_DIRECTORY_ENTRY_EXPORT"]])
    for export in pe.DIRECTORY_ENTRY_EXPORT.symbols:
        if export.name is not None:
            if (zlib.crc32(export.name) == hashed_api):
                return export.name.decode()
        else:
            continue

def RetrieveCRC(pipe, xref):
    """Retrieves a CRC32 hash of procedure from the specified address."""
    instr = pipe.cmdj("pdj -1 @ " + hex(xref))
    while ((instr[0]["type"] != "mov" or instr[0]["family"] != "cpu" or not 'ptr' in instr[0] or not 'val' in instr[0]) and instr[0]["offset"] != (pipe.cmdj("afoj @ " + hex(xref))["address"])):
        instr = pipe.cmdj("pdj -1 @ " + hex(instr[0]["offset"]))
    return (instr[0]["val"], instr[0]["offset"])

def RetrieveLibOrd(pipe, xref):
    """Retrieves the ordinal number of a library."""
    instr = pipe.cmdj("pdj -1 @ " + hex(xref))
    while ((instr[0]["type"] != "xor" and (instr[0]["type"] != "mov" or 'ptr' in instr[0] or not 'val' in instr[0])) and instr[0]["offset"] != (pipe.cmdj("afoj @ " + hex(xref))["address"])):
        instr = pipe.cmdj("pdj -1 @ " + hex(instr[0]["offset"]))
    if instr[0]["type"] != "xor":
        return instr[0]["val"]
    else:
        return 0

def LocLLACall(pipe):
    """Retrieves a call to LoadLibraryA which is located only in APIHashingFunc â€” function responsible for retrieving procedure using library ordinal and CRC32 hash of an API; renames the function."""
    for imp in pipe.cmdj("iij"):
        if (imp["name"] == "LoadLibraryA"):
            for xref in pipe.cmdj("axtj @ " + hex(imp["plt"])):
                api_hashing_func = pipe.cmdj("afoj @ " + hex(xref["from"]))["address"]
                pipe.cmd("afn APIHashingFunc @ " + hex(api_hashing_func))
                print("[+] Located API hahing function at {}".format(hex(api_hashing_func)))
                return xref["from"]

def main(args):
    with rzpipe.open(args.file) as rz:
        rz.cmd("aaa")
        instr = rz.cmdj("pdj -1 @ " + hex(LocLLACall(rz)))
        # Retrieving the address of an array with library names
        while (instr[0]["type"] != "upush" and instr[0]["offset"] != instr[0]["fcn_addr"]):
            instr = rz.cmdj("pdj -1 @ " + hex(instr[0]["offset"]))
            break
        # Address in the instruction points to the end of an array, so it has to be decreased to point to the assumed start of it 
        lib_list = [flag["name"][4:] for flag in rz.cmdj("fij " + str(LIBRARY_ARRAY_SIZE) + " @ " + hex(int(instr[0]["esil"].split(",")[0][2:], 16) - LIBRARY_ARRAY_SIZE))]
        
        for xref in rz.cmdj("axtj @ " + hex(instr[0]["fcn_addr"])):
            (hashed_api, hashed_api_addr) = RetrieveCRC(rz, xref["from"])
            lib_ordinal = RetrieveLibOrd(rz, xref["from"])
            api_name = DetermineAPI(os.path.join(os.environ["SYSTEMROOT"] + "\\System32", lib_list[lib_ordinal]), hashed_api)
            rz.cmd("CC " + api_name + " @ " + hex(hashed_api_addr))
            print("[+] Determined {} at {}".format(api_name, hex(hashed_api_addr)))
        rz.cmd("Ps " + args.output)
        print("[+] rzdb file with determined imports is written to {}".format(args.output))

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Import decryptor for cruloader second stage", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('-f', '--file', required=True, help='Full path to the second stage', default=argparse.SUPPRESS)
    parser.add_argument('-o', '--output', help='Output rzdb filename', default='second_stage.rzdb')
    
    main(parser.parse_args())